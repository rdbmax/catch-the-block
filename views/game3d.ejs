<!DOCTYPE html>
<html>
<head>
    <title>ThreeJs vs NodeJs</title>    
    <style>
        html, body { margin: 0px; }
        canvas { height : 100%; }
        #scores {
            position: absolute;
            top: 0px;
            left: 0px;
            color: white;
        }
    </style>
    <script src="three.min.js"></script>
    <script src="jquery.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
    var scene;
    window.onload = function() {
        //var addCube, group = {}, socket = io.connect('95.142.166.18:8089');
        //var addCube, group = {}, socket = io.connect('<%= adresse %>:<%= port %>');
        var addCube, group = {}, socket = io.connect('https://tranquil-ridge-5424.herokuapp.com/');
        var renderer, camera, light, myCube, target;
        function init () {
            renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.set( -15, 10, 10 );
            camera.lookAt( scene.position );
            light = new THREE.PointLight( 0xFFFF00 );
            light.position.set( -10, 20, 10 );
            scene.add( light );
            renderer.render( scene, camera );
            window.addEventListener( 'resize', onWindowResize, false );
            function onWindowResize() {
                windowHalfX = window.innerWidth / 2;
                windowHalfY = window.innerHeight / 2;
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }
            document.onkeydown = checkKey;
            function checkKey(e) {
                e = e || window.event;
                if( e.keyCode == '37' || e.keyCode == '38' || e.keyCode == '39' || e.keyCode == '40' ) {
                    e.preventDefault();
                    going(e.keyCode);
                    emitMove(e.keyCode);
                }
            }
            function going(direction) {
                if (direction == '37') myCube.position.z -= 1;
                else if (direction == '38') myCube.position.x += 1;
                else if (direction == '39') myCube.position.z += 1;
                else if (direction == '40') myCube.position.x -= 1;
            }
            socket.emit('nouveau_client', addCube({mine:true}));
            $('body').append("<p id='scores'><span>Me : </span><span id='myscore'>0</span><br/></p>");
        }
        function animate() {
            requestAnimationFrame( animate );
            render();
        }
        function render() {
            renderer.render( scene, camera );
        }
        function randomPosition() {
            return {
                x: Math.round(Math.random()*10),
                y: 0,
                z: Math.round(Math.random()*10)
            };
        }
        function randomColor() {
            return Math.random() * 0x808008 + 0x808080;
        }
        addCube = function addCube(obj) {
            var pos, pseudo, color;
            if( obj.position ) pos = obj.position;
            else pos = randomPosition();
            if( obj.pseudo ) pseudo = obj.pseudo;
            else pseudo = prompt('Quel est ton pseudo ?');
            if( obj.color ) color = obj.color;
            else color = randomColor();
            var geometry = new THREE.CubeGeometry( 2, 2, 2 ), material = new THREE.MeshPhongMaterial({ ambient: 0x030303, color: color, specular: 0x009900, shininess: 30, shading: THREE.FlatShading }), mesh = new THREE.Mesh( geometry, material );
            mesh.position = pos;
            mesh.name = pseudo;
            if( obj.mine ) {
                mesh.userData.score = 0;
                myCube = mesh;
                scene.add(myCube);
            }
            else if( obj.add ) scene.add( mesh );
            return {
                pseudo : pseudo,
                position: pos,
                scale: { x : 0, y : 0, z : 0},
                color: color,
                score: 0
            };
        }
        init();
        animate();

        socket.on('load_partners', function (obj) {
            $.each(obj.balls, function (x,message) {
                group[message.pseudo] = message;
                addCube({
                    position: message.position,
                    pseudo: message.pseudo,
                    color: message.color,
                    add: true
                });
                $('#scores').append("<span id='label_"+message.pseudo+"'>"+message.pseudo+" : </span><span id='score_"+message.pseudo+"'>"+message.score+"</span><br/>");
            });
            addCube({
                position : obj.target,
                add : true,
                color : 'white',
                pseudo : 'target'
            });
        });

        socket.on('nouveau_client', function (message) {
            group[message.pseudo] = message;
            addCube({
                position: message.position,
                pseudo: message.pseudo,
                color: message.color,
                add: true
            });
            $('#scores').append("<span id='label_"+message.pseudo+"'>"+message.pseudo+" : </span><span id='score_"+message.pseudo+"'>0</span><br/>");
        });

        function emitMove(codeMove) {
            socket.emit('move', myCube.position);
        }

        socket.on('move', function (message) {
            $.each(scene.children, function (x,y) {
                if( y.name == message.pseudo ) y.position = message.position;
            });
        });

        socket.on('newTarget', function (data) {
            $.each(scene.children, function (x,y) {
                if( y != undefined ) if( y.name == 'target' ) scene.remove( y );
            });
            addCube({
                position : data,
                add : true,
                color : 'white',
                pseudo : 'target'
            });
        });

        socket.on('scoreUp', function (name) {
            console.log(name);
            console.log(myCube.name);
            if( name == myCube.name ) {
                myCube.userData.score++;
                $('#myscore')[0].innerText = myCube.userData.score;
            }
            else {
                group[name].score++;
                $('#score_'+name)[0].innerText = group[name].score;
            }
        });

        socket.on('deconnexion', function (pseudo) {
            $('#score_'+pseudo).next().remove();
            $('#score_'+pseudo+', #label_'+pseudo).remove();
            $.each(scene.children, function (x,y) {
                if( y != undefined ) if( y.name == pseudo ) scene.remove( y );
            });
        });
    };
    </script>
</head>
<body></body>
</html>